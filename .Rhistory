geocode("Eastern and Midwestern Canada")
geocode("Eastern Canada")
geocode("Lebanon, New Hampshire")
geocode("St. Johnsbury, Vermont")
geocode("Salem, New York")
geocode("The Marine Mammal Center")
geocode("yeale, africa")
geocode("yeale, ivory coast")
geocode("northern and central Japan")
geocode("Japan")
geocode("University of Kentucky")
geocode("Tsavo National Park")
geocode("Nairobi National Park")
geocode("solio ranch")
geocode("Fakahatchee Strand,florida")
geocode("Tussen-die-Riviere Game Farm, Orange Free State")
geocode("Tussen-die-Riviere Game Farm")
geocode("Orange Free State")
geocode("Maple, Ontario")
geocode("Maple district, Ontario")
geocode("Sapulot, Sabah")
geocode("Sapulot, Sabah, Malasya")
geocode("Sapulot, Sabah, Malaysia")
geocode("chaco, argentina")
geocode("Corvallis, Oregon")
geocode("Svanoy, western Norway")
geocode("Svanoy, Norway")
geocode("Bremerhaven, Germany")
geocode("Engerdal Municipality, Norway")
geocode("Birganj Forest District")
geocode("Darjeeling")
geocode("Karnataka")
geocode("Shikari Bas, Asia")
geocode("Parsa, Asia")
geocode("Parsa, Shikari Bas, Asia")
geocode("tenasserim, Asia")
geocode("tenasserim")
geocode("kalimatan")
geocode("japan")
geocode("Hluhluwe–iMfolozi Park")
geocode("Hluhluwe–iMfolozi")
geocode("Mtethomusha")
geocode("thomas baine")
geocode("Thomas Baines Nature Reserve")
sessionInfo()
sessionInfo()
library(ggplot2)
qplot(diamons$carat,diamons$price,colour=clarity)
qplot(diamons$carat,diamons$price,colour=diamons$clarity)
head(diamons)
qplot(diamons$carat,diamons$price)
setwd("~/GitHub/QuBar")
library(ggplot2)
# now we have the dataframe "gammaData" with all the values we need to plot
gammaData<-read.csv("gammaData.csv",header=T)
minigamma<-gammaData[gammaData$sampleSize<33,]
factor(gammaData$Populations)->gammaData$pops
factor(minigamma$Populations)->minigamma$minipops
factor(minigamma$sampleSize)->minigamma$sampleSizeF
par(mfrow=c(1,2))
# plotting with ggplot, need to fix legends
#http://www.cookbook-r.com/Graphs/Legends_(ggplot2)/
# Fig X2a
# thinking how to plot the subset of samples sizes where gamma works a little bit better....
ggplot(minigamma, aes(x = sampleSizeF,y=Max.Gamma.value,fill=minipops,color=minipops)) + geom_boxplot(aes(fill=minipops))+ylim(0,20)
# Fig X2b
ggplot(gammaData, aes(x = sampleSize,y=Max.Gamma.value,fill=pops,color=pops)) + geom_point()+stat_smooth(method="loess")+geom_abline()+scale_fill_discrete(name="Populations",breaks=c("Pop1","Pop2","Pop3","Pop4"),labels=c("Theta=2g", "Theta=2ng","Theta=10g", "Theta=10ng"))
####################################
#numhaps=9
#hapdiv=0.7 #minvalue 0.001 if no information; this is PRIOR information
####################################
x=1
cdf=0
indprob=0
array<-NULL
while (cdf<0.99) {
cdfprev<-cdf
#  cdf<-pgamma(x,1,Hapdiv)
#  if use 1 as shape parameter keeping shape parameter constant doesn't account for increased variance (?) as numhaps go up,
#  e.g. error may be higher as you observe more...once it is working run it by somebody mathier.
cdf<-pgamma(x,numhaps,Hapdiv) #might be that numhaps is actually the shape parameter!!!! or: something else...non-gamma.
indprob<-cdf-cdfprev
happrob<-numhaps+(x-1)
array<-c(array,happrob)
array<-c(array,cdf)
array<-c(array,indprob)
#  print(happrob)
#  print(cdf)
x=x+1
}
par(mfrow=c(3,1))
probs<-t(matrix(array,nrow=3))
probs
#plot(probs[,1],probs[,3],col='red')
####################################
numhaps=9
hapdiv=0.7 #minvalue 0.001 if no information; this is PRIOR information
####################################
x=1
cdf=0
indprob=0
array<-NULL
while (cdf<0.99) {
cdfprev<-cdf
#  cdf<-pgamma(x,1,Hapdiv)
#  if use 1 as shape parameter keeping shape parameter constant doesn't account for increased variance (?) as numhaps go up,
#  e.g. error may be higher as you observe more...once it is working run it by somebody mathier.
cdf<-pgamma(x,numhaps,Hapdiv) #might be that numhaps is actually the shape parameter!!!! or: something else...non-gamma.
indprob<-cdf-cdfprev
happrob<-numhaps+(x-1)
array<-c(array,happrob)
array<-c(array,cdf)
array<-c(array,indprob)
#  print(happrob)
#  print(cdf)
x=x+1
}
par(mfrow=c(3,1))
probs<-t(matrix(array,nrow=3))
probs
#plot(probs[,1],probs[,3],col='red')
####################################
numhaps=9
hapdiv=0.7 #minvalue 0.001 if no information; this is PRIOR information
####################################
x=1
cdf=0
indprob=0
array<-NULL
while (cdf<0.99) {
cdfprev<-cdf
#  cdf<-pgamma(x,1,Hapdiv)
#  if use 1 as shape parameter keeping shape parameter constant doesn't account for increased variance (?) as numhaps go up,
#  e.g. error may be higher as you observe more...once it is working run it by somebody mathier.
cdf<-pgamma(x,numhaps,hapdiv) #might be that numhaps is actually the shape parameter!!!! or: something else...non-gamma.
indprob<-cdf-cdfprev
happrob<-numhaps+(x-1)
array<-c(array,happrob)
array<-c(array,cdf)
array<-c(array,indprob)
#  print(happrob)
#  print(cdf)
x=x+1
}
par(mfrow=c(3,1))
probs<-t(matrix(array,nrow=3))
probs
#plot(probs[,1],probs[,3],col='red')
qgamma(probs[,3])
qgamma(probs[,3],shape=0.5)
data<-read.csv("hapsegData.csv",header=T)
segdata<-unique(data[,c("Populations","segSites","sampleSize")])
# taking out the values of zero segregating sites
zero<-which(segdata$segSites==0)
segdata[-zero,]->segdata
# we need to define a maximum n, John identified that above 70 this behaves funny
maxn=60
maxk<-max(segdata$segSites)
theta<-c(2,2,10,10)
Q = 2 #theta
# subsetting data from the populations with theta=2
segdata2<-subset(segdata,Populations=="Pop1"|Populations=="Pop2")
# creating empty list to put the results
ndistT2<-list()
# looping in segdata and running Wakeley formula
for (z in 1:nrow(segdata2)){
name<-paste("seg",z,sep="")
obsvdk<-segdata2$segSites[z]
a <- c(1:maxn)
b <- c(1:maxk)
PSKv <- numeric(maxn*maxk)
PSKv <- matrix(PSKv,ncol=maxn)
colnames(PSKv)<-a
rownames(PSKv)<-b
for (n in 2:maxn) {
PSK=0
for (i in 2:n) {
PSK<-PSK + ((-1)^i)*(choose((n-1),(i-1)))*((i-1)/(Q+i-1))*(Q/(Q+i-1))^obsvdk
}
PSKv[obsvdk,n]<-PSKv[obsvdk,n]+PSK
obsvd<-PSKv[obsvdk,]
obsvd->ndistT2[[name]]
}
}
Q = 10 #theta
# subsetting data from the populations with theta=10
segdata10<-subset(segdata,Populations=="Pop3"|Populations=="Pop4")
# creating empty list to put the results
ndistT10<-list()
# looping in segdata and running Wakeley formula
for (z in 1:nrow(segdata10)){
name<-paste("seg",z,sep="")
obsvdk<-segdata2$segSites[z]
a <- c(1:maxn)
b <- c(1:maxk)
PSKv <- numeric(maxn*maxk)
PSKv <- matrix(PSKv,ncol=maxn)
colnames(PSKv)<-a
rownames(PSKv)<-b
for (n in 2:maxn) {
PSK=0
for (i in 2:n) {
PSK<-PSK + ((-1)^i)*(choose((n-1),(i-1)))*((i-1)/(Q+i-1))*(Q/(Q+i-1))^obsvdk
}
PSKv[obsvdk,n]<-PSKv[obsvdk,n]+PSK
obsvd<-PSKv[obsvdk,]
obsvd->ndistT10[[name]]
}
}
hist3D(x=seq(0,1,length.out=nrow(PSKv)),y=seq(0,1,length.out=ncol(PSKv)),PSKv,col=NULL,border="black",theta=30,phi=30,xlab="k",ylab="n",zlab="P{S=k}",alpha=0.35,main=paste((expression(theta))," = ",Q))
library(plot3D)
hist3D(x=seq(0,1,length.out=nrow(PSKv)),y=seq(0,1,length.out=ncol(PSKv)),PSKv,col=NULL,border="black",theta=30,phi=30,xlab="k",ylab="n",zlab="P{S=k}",alpha=0.35,main=paste((expression(theta))," = ",Q))
par(mfrow=c(1,1))
hist3D(x=seq(0,1,length.out=nrow(PSKv)),y=seq(0,1,length.out=ncol(PSKv)),PSKv,col=NULL,border="black",theta=30,phi=30,xlab="k",ylab="n",zlab="P{S=k}",alpha=0.35,main=paste((expression(theta))," = ",Q))
plot(obsvd,xlab="n",ylab="P(n|k)",ylim=c(0,0.15),main=paste("for K =",obsvdk, "and theta =",Q,"in black; for hapdiv in red"))
hist3D(x=seq(0,1,length.out=nrow(PSKv)),y=seq(0,1,length.out=ncol(PSKv)),PSKv,col=NULL,border="black",theta=2,phi=30,xlab="k",ylab="n",zlab="P{S=k}",alpha=0.35,main=paste((expression(theta))," = ",Q))
ndistT10[[1]]
plot(ndistT10[[1]])
maxn=50
maxk<-max(segdata$segSites)
# theta values in our four populations, our "known" value of the "real" population (n=1000 simulated populations in this round)
theta<-c(2,2,10,10)
# -----theta=2-----------
Q = 2 #theta
# subsetting data from the populations with theta=2
segdata2<-subset(segdata,Populations=="Pop1"|Populations=="Pop2")
# creating empty list to put the results
ndistT2<-list()
# looping in segdata and running Wakeley formula
for (z in 1:nrow(segdata2)){
name<-paste("seg",z,sep="")
obsvdk<-segdata2$segSites[z]
a <- c(1:maxn)
b <- c(1:maxk)
PSKv <- numeric(maxn*maxk)
PSKv <- matrix(PSKv,ncol=maxn)
colnames(PSKv)<-a
rownames(PSKv)<-b
for (n in 2:maxn) {
PSK=0
for (i in 2:n) {
PSK<-PSK + ((-1)^i)*(choose((n-1),(i-1)))*((i-1)/(Q+i-1))*(Q/(Q+i-1))^obsvdk
}
PSKv[obsvdk,n]<-PSKv[obsvdk,n]+PSK
obsvd<-PSKv[obsvdk,]
obsvd->ndistT2[[name]]
}
}
# The result of the loop is a list "ndistT2", with each component being one observed segregating site value, and within that a vector with length maxn, and the components are the probability values for that segsite according to Wakeley.
# -----theta=10-----------
Q = 10 #theta
# subsetting data from the populations with theta=10
segdata10<-subset(segdata,Populations=="Pop3"|Populations=="Pop4")
# creating empty list to put the results
ndistT10<-list()
# looping in segdata and running Wakeley formula
for (z in 1:nrow(segdata10)){
name<-paste("seg",z,sep="")
obsvdk<-segdata2$segSites[z]
a <- c(1:maxn)
b <- c(1:maxk)
PSKv <- numeric(maxn*maxk)
PSKv <- matrix(PSKv,ncol=maxn)
colnames(PSKv)<-a
rownames(PSKv)<-b
for (n in 2:maxn) {
PSK=0
for (i in 2:n) {
PSK<-PSK + ((-1)^i)*(choose((n-1),(i-1)))*((i-1)/(Q+i-1))*(Q/(Q+i-1))^obsvdk
}
PSKv[obsvdk,n]<-PSKv[obsvdk,n]+PSK
obsvd<-PSKv[obsvdk,]
obsvd->ndistT10[[name]]
}
}
# The result of the loop is a list "ndistT10", with each component being one observed segregating site value, and within that a vector with length maxn, and the components are the probability values for that segsite according to Wakeley.
plot(ndistT10[[1]])
View(segdata10)
nrow(segdata10)
length(ndistT10)
nrow(segdata)
nrow(data)
try<-subset(data,Populations=="Pop1")
hist(try)
hist(try$segSites)
library(lattice)
histogram(~try$segSites|try$sampleSize)
histogram(~segSites|sampleSize,data=try)
View(try)
histogram(~segSites|factor(sampleSize),data=try)
summary(try$segSites)
aggregate(try,list("segSites"),summary)
aggregate(try,list("sampleSize"),summary(segSites))
aggregate(try$segSites,by=list("sampleSize"),FUN=summary)
aggregate(try$segSites,by=list("try$sampleSize"),FUN=summary)
aggregate(try$segSites,by=list(try$sampleSize),FUN=summary)
points(ndistT10[[2]],col="green")
abline(v=2)
subset(data,Populations=="Pop1")->pop1
subset(data,Populations=="Pop2")->pop2
subset(data,Populations=="Pop3")->pop3
subset(data,Populations=="Pop4")->pop4
# plot histogram to see distribution of segSites
histogram(~segSites|sampleSize,data=pop1)
histogram(~segSites|factor(sampleSize),data=pop1)
histogram(~segSites|factor(sampleSize),data=pop2)
histogram(~segSites|factor(sampleSize),data=pop3)
histogram(~segSites|factor(sampleSize),data=pop4)
help(histogram)
histogram(~segSites|factor(sampleSize),data=pop1, main="Population 1-t2g")
histogram(~segSites|factor(sampleSize),data=pop2,main="Population 1-t2ng")
histogram(~segSites|factor(sampleSize),data=pop3,main="Population 1-t10g")
histogram(~segSites|factor(sampleSize),data=pop4,main="Population 1-t10ng")
histogram(~segSites|factor(sampleSize),data=pop1, main="Population 1-t2g")
histogram(~segSites|factor(sampleSize),data=pop2,main="Population 2-t2ng")
histogram(~segSites|factor(sampleSize),data=pop3,main="Population 3-t10g")
histogram(~segSites|factor(sampleSize),data=pop4,main="Population 4-t10ng")
aggregate(try$segSites,by=list(try$sampleSize),FUN=summary)
aggregate(pop2$segSites,by=list(pop2$sampleSize),FUN=summary)
aggregate(pop3$segSites,by=list(pop3$sampleSize),FUN=summary)
aggregate(pop4$segSites,by=list(pop4$sampleSize),FUN=summary)
# looping in segdata and running Wakeley formula
for (i in 1:maxk){
name<-paste("seg",z,sep="")
obsvdk<-i
a <- c(1:maxn)
b <- c(1:maxk)
PSKv <- numeric(maxn*maxk)
PSKv <- matrix(PSKv,ncol=maxn)
colnames(PSKv)<-a
rownames(PSKv)<-b
for (n in 2:maxn) {
PSK=0
for (i in 2:n) {
PSK<-PSK + ((-1)^i)*(choose((n-1),(i-1)))*((i-1)/(Q+i-1))*(Q/(Q+i-1))^obsvdk
}
PSKv[obsvdk,n]<-PSKv[obsvdk,n]+PSK
obsvd<-PSKv[obsvdk,]
obsvd->ndistT2[[name]]
}
}
length(ndistT2)
maxk
# load data with observed segregating sites in the samples
data<-read.csv("hapsegData.csv",header=T)
# we need to define a maximum n, John identified that above 70 this behaves funny, actually for 60 too, so I put 50
maxn=50
maxk<-max(data$segSites)
# theta values in our four populations, our "known" value of the "real" population (n=1000 simulated populations in this round)
theta<-c(2,2,10,10)
# -----theta=2-----------
Q = 2 #theta
# creating empty list to put the results
ndistT2<-list()
# looping in segdata and running Wakeley formula
for (i in 1:maxk){
name<-paste("seg",z,sep="")
obsvdk<-i
a <- c(1:maxn)
b <- c(1:maxk)
PSKv <- numeric(maxn*maxk)
PSKv <- matrix(PSKv,ncol=maxn)
colnames(PSKv)<-a
rownames(PSKv)<-b
for (n in 2:maxn) {
PSK=0
for (i in 2:n) {
PSK<-PSK + ((-1)^i)*(choose((n-1),(i-1)))*((i-1)/(Q+i-1))*(Q/(Q+i-1))^obsvdk
}
PSKv[obsvdk,n]<-PSKv[obsvdk,n]+PSK
obsvd<-PSKv[obsvdk,]
obsvd->ndistT2[[name]]
}
}
maxk
length(ndistT2)
for (i in 1:maxk){
name<-paste("seg",zi,sep="")
obsvdk<-i
a <- c(1:maxn)
b <- c(1:maxk)
PSKv <- numeric(maxn*maxk)
PSKv <- matrix(PSKv,ncol=maxn)
colnames(PSKv)<-a
rownames(PSKv)<-b
for (n in 2:maxn) {
PSK=0
for (i in 2:n) {
PSK<-PSK + ((-1)^i)*(choose((n-1),(i-1)))*((i-1)/(Q+i-1))*(Q/(Q+i-1))^obsvdk
}
PSKv[obsvdk,n]<-PSKv[obsvdk,n]+PSK
obsvd<-PSKv[obsvdk,]
obsvd->ndistT2[[name]]
}
}
for (i in 1:maxk){
name<-paste("seg",i,sep="")
obsvdk<-i
a <- c(1:maxn)
b <- c(1:maxk)
PSKv <- numeric(maxn*maxk)
PSKv <- matrix(PSKv,ncol=maxn)
colnames(PSKv)<-a
rownames(PSKv)<-b
for (n in 2:maxn) {
PSK=0
for (i in 2:n) {
PSK<-PSK + ((-1)^i)*(choose((n-1),(i-1)))*((i-1)/(Q+i-1))*(Q/(Q+i-1))^obsvdk
}
PSKv[obsvdk,n]<-PSKv[obsvdk,n]+PSK
obsvd<-PSKv[obsvdk,]
obsvd->ndistT2[[name]]
}
}
length(ndistT2)
maxk
head(ndistT2)
tail(ndistT2)
for (j in 1:maxk){
name<-paste("seg",j,sep="")
obsvdk<-j
a <- c(1:maxn)
b <- c(1:maxk)
PSKv <- numeric(maxn*maxk)
PSKv <- matrix(PSKv,ncol=maxn)
colnames(PSKv)<-a
rownames(PSKv)<-b
for (n in 2:maxn) {
PSK=0
for (i in 2:n) {
PSK<-PSK + ((-1)^i)*(choose((n-1),(i-1)))*((i-1)/(Q+i-1))*(Q/(Q+i-1))^obsvdk
}
PSKv[obsvdk,n]<-PSKv[obsvdk,n]+PSK
obsvd<-PSKv[obsvdk,]
obsvd->ndistT2[[name]]
}
}
head(ndistT2)
ndistT2[[-1]]->t2list
ndistT2[[1]]<-NULL
head(ndistT2)
str(ndistT2)
ndistT2[[2]]
ndistT2[[1]]
for (j in 1:nrow(segdata10)){
name<-paste("seg",j,sep="")
obsvdk<-j
a <- c(1:maxn)
b <- c(1:maxk)
PSKv <- numeric(maxn*maxk)
PSKv <- matrix(PSKv,ncol=maxn)
colnames(PSKv)<-a
rownames(PSKv)<-b
for (n in 2:maxn) {
PSK=0
for (i in 2:n) {
PSK<-PSK + ((-1)^i)*(choose((n-1),(i-1)))*((i-1)/(Q+i-1))*(Q/(Q+i-1))^obsvdk
}
PSKv[obsvdk,n]<-PSKv[obsvdk,n]+PSK
obsvd<-PSKv[obsvdk,]
obsvd->ndistT10[[name]]
}
}
ndistT10[[1]]<-NULL
Q = 10 #theta
# creating empty list to put the results
ndistT10<-list()
# looping in segdata and running Wakeley formula
for (j in 1:nrow(segdata10)){
name<-paste("seg",j,sep="")
obsvdk<-j
a <- c(1:maxn)
b <- c(1:maxk)
PSKv <- numeric(maxn*maxk)
PSKv <- matrix(PSKv,ncol=maxn)
colnames(PSKv)<-a
rownames(PSKv)<-b
for (n in 2:maxn) {
PSK=0
for (i in 2:n) {
PSK<-PSK + ((-1)^i)*(choose((n-1),(i-1)))*((i-1)/(Q+i-1))*(Q/(Q+i-1))^obsvdk
}
PSKv[obsvdk,n]<-PSKv[obsvdk,n]+PSK
obsvd<-PSKv[obsvdk,]
obsvd->ndistT10[[name]]
}
}
Q = 10 #theta
# creating empty list to put the results
ndistT10<-list()
# looping in segdata and running Wakeley formula
for (j in 1:maxk){
name<-paste("seg",j,sep="")
obsvdk<-j
a <- c(1:maxn)
b <- c(1:maxk)
PSKv <- numeric(maxn*maxk)
PSKv <- matrix(PSKv,ncol=maxn)
colnames(PSKv)<-a
rownames(PSKv)<-b
for (n in 2:maxn) {
PSK=0
for (i in 2:n) {
PSK<-PSK + ((-1)^i)*(choose((n-1),(i-1)))*((i-1)/(Q+i-1))*(Q/(Q+i-1))^obsvdk
}
PSKv[obsvdk,n]<-PSKv[obsvdk,n]+PSK
obsvd<-PSKv[obsvdk,]
obsvd->ndistT10[[name]]
}
}
head(ndistT10)
tail(ndistT10)
