---
title: "Untitled"
author: "Paula Pappalardo"
date: "Monday, August 31, 2015"
output: html_document
---

# Taking "field samples"

```{r taking field samples}
library(gap)
library(PopGenome)

# this way, we read the same files that were simulated only once, and the same that we read with PopGenome

read.ms.output("theta2NoGrowth.out",is.file=T)->pop2
read.ms.output("theta10NoGrowth.out",is.file=T)->pop4
read.ms.output("theta20NoGrowth.out",is.file=T)->pop6

# --------sampling from each population---------
# vector with all the populations for loops or easy coding
pop<-list(pop2,pop4,pop6)

# vector with the sizes we want to sample
popsizes<-c(2:50)
popsizes<-c(2,4,8,16,32,64,128)

# we extract the gametes matrix for each population, from there we take the samples, we put the matrix obtained in each "sample" in a list called "samples", and the result for each population in a list called "populations"

populations<-list() #empty list to put results
set.seed(123) #set seed for random sampling

# loop in each population to take the field samples, 100 replicates for each sampling size
for(i in 1:length(pop)){
  pop[[i]]->ourpop #pick a population
  namepop<-paste("popOrigen",i,sep="")
  t(ourpop$gametes[[1]])->mat #transpose matrix to have individuals as rows
  samples<-list() #empty list to put the sampling of each sample size
    for(j in popsizes){
        name<-paste("sampleSize",j,sep="")
        replicates<-list() #empty list to put each replicate (n=100)
        for (k in 1:100){
        namerep<-paste("replicate",k,sep="")  
        mat[sample(nrow(mat),size=j,replace=FALSE),]->rep
        rep->replicates[[namerep]]
        }
        replicates->samples[[name]]
      }
  samples->populations[[namepop]]
} # now in each of the 4 components of the list "populations", we have 7 list with each component corresponding to each sample size, and within each of this list we have 100 components corresponding to each replicate of the sampled matrix.
```

The object **populations** has 6 components (one for each population), each one include 7 lists (one for each sampling size), and within each of the sampling sizes we have a list with the 100 matrix sampled.

# Calculating haplotypes 

Now we are going to calculate number of  haplotypes and number of segregating sites for each of the replicates in each of the samples in each of the 6 populations. The loops takes a while to be able to do it for all the replicates.

```{r calculating haplotypes}
# Now for each sample we need to calculate the segregating sites and number of haplotypes
# the haplotype number can be extracted by doing unique() of the matrix
hapResults<-list()
for(i in 1:length(pop)){
  populations[[i]]->popnow
  namepop<-paste("popOrigen",i,sep="")
  samples<-list()
  for (j in 1:length(popsizes)){
    namesample<-paste("sampleSize",j,sep="")  
    popnow[[j]]->samplenow
    for (k in 1:100){
      sapply(samplenow,function(x) nrow(unique(x)))->result
      unlist(result)->replicates
      }
    replicates->samples[[namesample]]
    }
  samples->hapResults[[namepop]]
} # now hapResults is a list of vectors with the haplotypes number for each population, in each sample size
```

Since this process is really time consuming, we want to save our results in a dataframe.

```{r making haplotypes dataframe}
# we want to loop in "hapresults" and for each population extract the number of haplotypes and put all in the same dataframe

library(reshape)

# create dataframe to hold the data
zerodata<-data.frame(Pop=NA,Theta=NA,growth=NA,variable=NA,value=NA)
thetas<-c("two","two","ten","ten","twenty","twenty")
growths<-c("yes","no","yes","no","yes","no")

# loop through populations and rbind data
for (i in 1:length(pop)){
  hapResults[[i]]->pophaps
  haps <-data.frame(do.call(rbind, pophaps))
  as.data.frame(t(haps))->datahaps
  datahaps$Theta<-thetas[i]
  datahaps$growth<-growths[i]
  datahaps$Pop<-i
  newdata<-melt(datahaps,id=c("Pop","Theta","growth"))
  rbind(zerodata,newdata)->zerodata
}

# organize and save data
zerodata[complete.cases(zerodata$Pop),]->numHaps
as.factor(numHaps$variable)->numHaps$variable
names(numHaps)<-c("Pop","Theta","Growth","samplingSize","n.haplotypes")
levels(numHaps$samplingSize)<-c("2","4","8","16","32","64","128")

# run only once
#write.csv(numHaps,"numberHaplotypes.csv")
```

Now we have the dataframe "numberHaplotypes" with the number of haplotypes for each replicate, for each population, and we don't need to run the chunk everytime.

# Calculating segregating sites

We are going to do a similar procedure to estimate the number of segregating sites. We first created a function to estimate the number of segregating sites from the gametes matrix provided by the MS simulation. And the we apply that looping over our samples.

```{r calculating segregating sites}
# load function to estimate segregating sites, it works taking a matrix of gametes and returning a numeric value, the number of segregating sites.
estimate.segSites <- function(myMatrix){
  answers<-rep(NA,(nrow(myMatrix)-1))
  sites<-rep(NA,ncol(myMatrix))
    for (j in 1:ncol(myMatrix)){
      for (i in 1:(nrow(myMatrix)-1)){
        (myMatrix[i+1,j]==myMatrix[1,j])->answers[i]
      }
      if (all(answers)==TRUE) {0->sites[j]}
      else {1->sites[j]}
      }
    sum(sites,na.rm=T)->segSites
    return(segSites)
  }

# to get segsites for each population we need to use our custome function in a loop
segResults<-list()
for(i in 1:length(pop)){
  populations[[i]]->popnow
  namepop<-paste("popOrigen",i,sep="")
  samples<-list()
  for (j in 1:length(popsizes)){
    namesample<-paste("sampleSize",j,sep="")
    popnow[[j]]->samplenow
    sapply(samplenow,function(x) estimate.segSites(x))->result
    result->samples[[namesample]]
    }
  samples->segResults[[namepop]]
}  # now segResults is a list of 4 lists (one for each population), within each of those list compose of a list of 7 vectors, one for each sample size, and with a length of 100, where each component is the segregating sites for the 100 replicates. 
```

To save our results in a dataframe:

```{r making segSites dataframe}
# we want to loop in "segResults" and for each population extract the number of segregating sites and put all in the same dataframe
library(reshape)

# create dataframe to hold the data
zerodata<-data.frame(Pop=NA,Theta=NA,growth=NA,variable=NA,value=NA)
thetas<-c("two","ten","twenty")
growths<-c("no","no","no")

# loop through populations and rbind data
for (i in 1:length(pop)){
  segResults[[i]]->popsegs
  segs <-data.frame(do.call(rbind, popsegs))
  as.data.frame(t(segs))->dataseg
  dataseg$Theta<-thetas[i]
  dataseg$growth<-growths[i]
  dataseg$Pop<-i
  newdata<-melt(dataseg,id=c("Pop","Theta","growth"))
  rbind(zerodata,newdata)->zerodata
}

# organize and save data
zerodata[complete.cases(zerodata$Pop),]->numSegSites
as.factor(numSegSites$variable)->numSegSites$variable
names(numSegSites)<-c("Pop","Theta","Growth","samplingSize","n.seg.sites")
levels(numSegSites$samplingSize)<-as.character(c(2:50))

# run only once
write.csv(numSegSites,"numberSegSites_31Ago2015.csv")
```

Now we have the dataframe "numberSegSites" with the number of segregating sites for each replicate, for each population, and we don't need to run the chunk everytime.
